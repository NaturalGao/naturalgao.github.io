{"meta":{"title":"NaturalGao","subtitle":null,"description":null,"author":"NaturalGao","url":"https://naturalgao.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2022-03-05T16:05:38.296Z","updated":"2022-03-05T16:05:38.296Z","comments":true,"path":"links/index.html","permalink":"https://naturalgao.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-05T15:27:38.650Z","updated":"2022-03-05T15:27:38.650Z","comments":false,"path":"categories/index.html","permalink":"https://naturalgao.github.io/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2022-03-05T15:38:15.491Z","updated":"2022-03-05T15:38:15.491Z","comments":true,"path":"repository/index.html","permalink":"https://naturalgao.github.io/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-03-05T15:13:01.384Z","updated":"2022-03-05T15:13:01.384Z","comments":false,"path":"about/index.html","permalink":"https://naturalgao.github.io/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"硬链接与软链接详解","slug":"硬链接与软链接详解","date":"2019-12-17T04:42:52.000Z","updated":"2022-03-05T16:14:06.421Z","comments":true,"path":"2019/12/17/硬链接与软链接详解/","link":"","permalink":"https://naturalgao.github.io/2019/12/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"引言Linux 基础是非常重要得，无论是工作还是我们平时得学习，掌握 Linux 对你的学习道路一定能提供不少帮助。 下面简单的介绍下 Linux 中的硬链接和软连接，为了你更好的理解我下面的分享，你需要掌握 Linux 中的 inode 概念，如果你还不知道，推荐你到我的另一篇分享，先了解 inode。传送门 硬链接什么是硬链接Linux 中文件的inode号码与文件名一般都是一对一的关系，但是也可以多个一对多（多个文件名指向一个 inode 号码），称为硬链接。 特点 可以用不同的文件名访问同样的内容 对其中一个文件内容修改时，会影响到其他文件的内容。 删除其中一个文件时，其他文件可以正常访问，不受影响 实例首先,创建一个测试文件一，并写入 “做个哎记录的人” 1vim 1.txt 接着创建一个硬链接 格式：ln 源文件 目标文件 1ln 1.txt 2.txt 可以看到执行命令后多了个 2.txt 我们打开 2.txt 看看~~ 1vim 2.txt 发现内容跟 1.txt 一样，跟 copy 差不多，但也是有取别： 硬链接，无论是修改源文件还是目标文件，是会影响其它文件的，而 copy 后的文件修改是不会影响源文件的，而为什么不会影响到呢，无非就是 inode 的问题 我 copy 2.txt 到 3.txt, 我们可以通过一下命令来查看区别： 1ls -i 从图中可以发现, 1 和 2 的 inode 号码是一样的，所以修改其中一个文件，其余文件内容会随之变化. copy 出来的 3.txt 生成了个新的 inode 号码，所以是不会影响源文件的。所以验证了我们上面那个结论。 我们再验证一下，修改 inode 号码一样的文件，其它文件是否会随之改变。 我打开 2.txt 修改里面的内容，看 1.txt 是否有更新 发现 1.txt 也更新了 验证了我们的 1,2 条结论。 那我们把 2.txt 删除试试 发现 1.txt 还在，第三条结论也没有问题。 软链接通过上面的验证，相信大家对 Linux 的硬链接，应该掌握得差不多了，那我们接着来讲讲软连接，如果你已经掌握了硬链接，那软连接 很快就能掌握。 硬链接和软连接区别 硬链接 inode 号码一致，软连接相反。 硬链接读的内容是不同文件的内容，软连读的是源文件的内容。 实例通过以下命令创建一个软连接 命令结构：ln 源文件 目标文件 1ln -s 1.txt 2.txt 观察 2.txt 后面，什么意思呢，就是 把 2.txt 路径指向 1.txt 的路径，当我们访问 2.txt 的时候，实际读取的是 1.txt 的内容。 我们访问 2.txt 看看 1vim 2.txt 内容一致，没问题。怎么验证我们上面说的实际读取的是 1.txt 的内容呢？很好验证，我们把 1.txt 删除了。 明显看到,删除 1.txt 后 字变红了，为什么呢？很好理解，有错误，文件找不到了嘛，我们把 1.txt 删除了，而 2.txt 还指向 1.txt，一个不存在的文件。 我们试着访问下 2.txt 1cat 2.txt 发现报了个错误，文件找不到，所以我们的结论没有问题。 篇尾相信到这里你对 Linux 的 inode 、硬链接、软连接已经掌握得差不多了，希望能帮助到在看得你。 个人博客 原文","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://naturalgao.github.io/tags/Linux/"}]},{"title":"你真的对 Linux 中的 Inode 了解吗？","slug":"你真的对-Linux-中的-Inode-了解吗？","date":"2019-12-16T13:44:52.000Z","updated":"2022-03-05T16:13:42.828Z","comments":true,"path":"2019/12/16/你真的对-Linux-中的-Inode-了解吗？/","link":"","permalink":"https://naturalgao.github.io/2019/12/16/%E4%BD%A0%E7%9C%9F%E7%9A%84%E5%AF%B9-Linux-%E4%B8%AD%E7%9A%84-Inode-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/","excerpt":"","text":"引言inode 是一个Linux 非常重要的知识点，了解它有利于我们对Linux系统的进一步了解。 今天无意中看到了阮一峰老师对inode做的一个博客笔记，我这里简单的记录下学到的东西。 概念存储单位： 扇区 （Sector），存世512字节（相当于0.5kb） 块（block），8个Sector 组成一个 block 文件存储分为两个部分： 数据存储 文件元信息 文件元信息就是inode inode内容inode文件元信息包含以下内容: 文件的字节数 文件拥有者的User ID 文件的Group ID 文件的读、写、执行权限 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。 链接数，即有多少文件名指向这个inode 文件数据block的位置 查看inode信息1stat 1.txt 查看硬盘的inode总数和已经使用数量1df -i inode号码每个文件都会有inode号码，相当于mysql 数据库里的表id，用来查找数据的。每个文件名都会对应一个inode号码，我们打开一个文件的时候实际经历了以下步骤： 通过文件名去找对应的inode号码 通过inode号码获取inode信息 通过inode信息查找数据所在的block，读取数据 查看文件&#x2F;目录的inode号码1ls -i 1.txt 特殊作用由于inode号码与文件名分离，这种机制导致了一些Unix&#x2F;Linux系统特有的现象。 1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。 2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。 3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。 第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。 篇尾坚持每天学一点，知识是需要日积月累的，加油~ 分享给大家~ 参考 个人博客 原文","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://naturalgao.github.io/tags/Linux/"}]},{"title":"PHP实现简单的数据采集","slug":"PHP实现简单的数据采集","date":"2019-12-14T19:05:09.000Z","updated":"2022-03-05T16:13:43.069Z","comments":true,"path":"2019/12/15/PHP实现简单的数据采集/","link":"","permalink":"https://naturalgao.github.io/2019/12/15/PHP%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/","excerpt":"","text":"引言​ 说到数据采集大家首先都会想到python,代码简洁，高效，很容易就可以实现数据采集。 ​ 那PHP如何实现数据采集呢？非常简单。 概念​ 那什么是数据采集呢？以下是百度百科的介绍： ​ 数据采集，又称数据获取，是利用一种装置，从系统外部采集数据并输入到系统内部的一个接口。数据采集技术广泛应用在各个领域。 你可以简单的理解为偷别人网站的数据。 需要的扩展包1. Guzzle 这是一个PHP HTTP客户端，可以轻松发送HTTP请求并轻松与Web服务集成。 安装方式： 1composer require guzzlehttp/guzzle:~6.0 或者： 在composer.json加入 1234&quot;require&quot;: &#123; &quot;guzzlehttp/guzzle&quot;: &quot;~6.0&quot; &#125;&#125; 2. QueryList​ QueryList是一个基于phpQuery的PHP通用列表采集类,得益于phpQuery，让使用QueryList几乎没有任何学习成本，只要会CSS3选择器就可以轻松使用QueryList了，它让PHP做采集像jQuery选择元素一样简单。 QueryList的几个特点: 学习简单：只有一个核心的API 使用简单：用jQuery选择器来选择页面元素 自带过滤功能，可过滤掉无用的内容 支持无限层级嵌套采集 采集结果直接以采集规则以列表的形式有序的返回 支持扩展 我们可以使用它来过滤html内容 安装方式： 1composer require jaeger/querylist:V3.2.1 采集案例 我们以 LearnKu 社区为例，我们将采集社区的帖子信息，并把这些信息存入文件和存入mysql数据库。 1.安装依赖在命令行输入以下命令 1composer init 引入依赖 123456789101112&#123; &quot;require&quot;: &#123; &quot;guzzlehttp/guzzle&quot;: &quot;~6.0@dev&quot;, &quot;jaeger/querylist&quot;: &quot;V3.2.1&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;App\\\\&quot;: &quot;app/&quot; &#125; &#125;&#125; 安装依赖 1composer install 2.采集类app\\Handle\\ClientHandle.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace App\\Handle;use GuzzleHttp\\Client;use QL\\QueryList;class ClientHandle&#123; private $client; public function __construct() &#123; $this-&gt;client = new Client([&#x27;verify&#x27; =&gt; false]); &#125; public function queryBody($url, $rules) &#123; $html = $this-&gt;sendRequest($url); $data = QueryList::Query($html, $rules)-&gt;getData(function ($item) &#123; if (array_key_exists(&#x27;link&#x27;,$item))&#123; $content = $this-&gt;sendRequest($item[&#x27;link&#x27;]); $item[&#x27;post&#x27;] = QueryList::Query($content, [ &#x27;title&#x27; =&gt; [&#x27;div.pull-left&gt;span&#x27;, &#x27;text&#x27;], &#x27;review&#x27; =&gt; [&#x27;p&gt;span.text-mute:eq(0)&#x27;, &#x27;text&#x27;], &#x27;comment&#x27; =&gt; [&#x27;p&gt;span.text-mute:eq(1)&#x27;, &#x27;text&#x27;], &#x27;content&#x27; =&gt; [&#x27;div.content-body&#x27;, &#x27;html&#x27;], &#x27;created_at&#x27; =&gt; [&#x27;p&gt;a&gt;span&#x27;, &#x27;title&#x27;], &#x27;updated_at&#x27; =&gt; [&#x27;p&gt;a:eq(2)&#x27;, &#x27;data-tooltip&#x27;] ])-&gt;data[0]; &#125; return $item; &#125;);//查看采集结果 return $data; &#125; private function sendRequest($url) &#123; $response = $this-&gt;client-&gt;request(&#x27;GET&#x27;, $url, [ &#x27;headers&#x27; =&gt; [ &#x27;User-Agent&#x27; =&gt; &#x27;testing/1.0&#x27;, &#x27;Accept&#x27; =&gt; &#x27;application/json&#x27;, &#x27;X-Foo&#x27; =&gt; [&#x27;Bar&#x27;, &#x27;Baz&#x27;] ], &#x27;form_params&#x27; =&gt; [ &#x27;foo&#x27; =&gt; &#x27;bar&#x27;, &#x27;baz&#x27; =&gt; [&#x27;hi&#x27;, &#x27;there!&#x27;] ], &#x27;timeout&#x27; =&gt; 3.14, ]); $body = $response-&gt;getBody();//获取到页面源码 $html = (string)$body; return $html; &#125;&#125; 简单分析： __construct 构造函数中我们实例化了一个 guzzleClient，用来发起http请求的。 sendRequest 是传入url，然后发起一个http请求并返回目标的html源码。 queryBody,接收一个url，和需要采集的规则，这里不做延伸 queryList，只要会使用jquery，那相信你很快上手。 12345678910111213141516171819202122232425262728 public function queryBody($url, $rules) &#123; //发起一个请求，接收html源码 $html = $this-&gt;sendRequest($url); //将内容$html，和规则$rules 传给QueryList的静态方法Query处理，并获取数据。 $data = QueryList::Query($html, $rules)-&gt;getData(function ($item) &#123; //我首先获取的是列表页，然后通过列表的link链接再去获取文章的详细信息。 //判断是否匹配到link if (array_key_exists(&#x27;link&#x27;,$item))&#123; //获取详情页的html源码 $content = $this-&gt;sendRequest($item[&#x27;link&#x27;]); //再交给QueryList 处理数据 $item[&#x27;post&#x27;] = QueryList::Query($content, [ &#x27;title&#x27; =&gt; [&#x27;div.pull-left&gt;span&#x27;, &#x27;text&#x27;], &#x27;review&#x27; =&gt; [&#x27;p&gt;span.text-mute:eq(0)&#x27;, &#x27;text&#x27;], &#x27;comment&#x27; =&gt; [&#x27;p&gt;span.text-mute:eq(1)&#x27;, &#x27;text&#x27;], &#x27;content&#x27; =&gt; [&#x27;div.content-body&#x27;, &#x27;html&#x27;], &#x27;created_at&#x27; =&gt; [&#x27;p&gt;a&gt;span&#x27;, &#x27;title&#x27;], &#x27;updated_at&#x27; =&gt; [&#x27;p&gt;a:eq(2)&#x27;, &#x27;data-tooltip&#x27;] ])-&gt;data[0]; //采集到的是一个集合，所以我只取第一个 data[0] &#125; return $item; &#125;);//查看采集结果 return $data; &#125; 3. PDO类App\\Handle\\PdoHandle.php 我们使用PDO来操作数据库,这里我简单实现一个类 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\Handle;class PdoHandle&#123; public $source; private $driver; private $host; private $dbname; private $username; private $password; /** * PdoHandle constructor. */ public function __construct($driver = &#x27;mysql&#x27;, $host = &#x27;localhost&#x27;, $dbname = &#x27;caiji&#x27;, $username = &#x27;root&#x27;, $password = &#x27;&#x27;) &#123; $this-&gt;driver = $driver; $this-&gt;host = $host; $this-&gt;dbname = $dbname; $this-&gt;username = $username; $this-&gt;password = $password; $dsn = $this-&gt;driver . &#x27;:host=&#x27; . $this-&gt;host . &#x27;;dbname=&#x27; . $this-&gt;dbname; $this-&gt;source = new \\PDO($dsn, $this-&gt;username, $this-&gt;password); $this-&gt;source-&gt;setAttribute(\\PDO::ATTR_ERRMODE, \\PDO::ERRMODE_EXCEPTION); &#125;&#125; 相信都看得懂，就不介绍了 4. 写入文件我们把采集到的内容，写入到文件里 12345678910111213141516171819202122232425&lt;?php//设置请求时间无限制set_time_limit(0);//引入自动加载require &#x27;../vendor/autoload.php&#x27;;//规则， 只取下标小于5的 也就是前5条数据$rules = [ &#x27;title&#x27; =&gt; [&#x27;span.topic-title:lt(5)&#x27;, &#x27;text&#x27;], &#x27;link&#x27; =&gt; [&#x27;a.topic-title-wrap:lt(5)&#x27;, &#x27;href&#x27;]];//采集$url = &quot;https://learnku.com/laravel&quot;;$client = new \\App\\Handle\\ClientHandle();$data = $client-&gt;queryBody($url, $rules);//因为我们请求了两级，所以返回的数组需要处理成一级数组$data = array_map(function ($item) &#123; return $item[&#x27;post&#x27;];&#125;, $data);//写入文件$handle = fopen(&#x27;2.php&#x27;,&#x27;w&#x27;);$str = &quot;&lt;?php\\n&quot;.var_export($data, true).&quot;;&quot;;fwrite($handle,$str);fclose($handle); 稍等几秒后，你就可以看到文件目录下多出个 2.php 的文件了，里面有数据代表采集成功~ 5. 写入数据库把采集到的内容写入到数据库里 1. 创建表首先我们创建一张 posts表并有以下字段： 1`title`, `review`, `comment`, `content`,`created_at`,`updated_at` created_at 和 updated_at 建议不要强制为时间类型和必填，否则需要再处理以下数据 2.操作1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpset_time_limit(0);require &#x27;../vendor/autoload.php&#x27;;$rules = [ &#x27;title&#x27; =&gt; [&#x27;span.topic-title&#x27;, &#x27;text&#x27;], &#x27;link&#x27; =&gt; [&#x27;a.topic-title-wrap&#x27;, &#x27;href&#x27;]];$url = &quot;https://learnku.com/laravel&quot;;$client = new \\App\\Handle\\ClientHandle();$data = $client-&gt;queryBody($url, $rules);$data = array_map(function ($item) &#123; return $item[&#x27;post&#x27;];&#125;, $data);//编写sql语句$sql = &quot;INSERT INTO `posts`(`title`, `review`, `comment`, `content`,`created_at`,`updated_at`) VALUES&quot;;//再过滤下没有匹配到符合条件的特殊数据，避免入库的时候麻烦$data = array_filter($data,function($item)&#123; return count($item) == 6;&#125;);//重置数组下标sort($data);//组合sql语句foreach ($data as $key =&gt; $item) &#123; //内容是有html标签的，所以我们要用 base64 处理下才能入库 $item[&#x27;content&#x27;] = base64_encode($item[&#x27;content&#x27;]); $value = &quot;&#x27;&quot; . implode(&quot;&#x27;,&#x27;&quot;, array_values($item)) . &quot;&#x27;&quot;; $sql .= &quot;($value)&quot;; if (count($data) - 1 != $key) &#123; $sql .= &quot;,&quot;; &#125;&#125;//采集$db = new \\App\\Handle\\PdoHandle();try &#123; $db-&gt;source-&gt;query($sql); echo &#x27;采集入库成功!&#x27;;&#125; catch (PDOException $exception) &#123; echo $exception-&gt;getMessage();&#125; 骚等几秒钟后，你就可以看到网页上输出 ‘采集入库成功’ 的字样，那代表成功了~ 我们也可以只采集前几条，只需要重写**$rules**规则就行了 例如：只取前5条,我们可以这样写。 1234$rules = [ &#x27;title&#x27; =&gt; [&#x27;span.topic-title:lt(5)&#x27;, &#x27;text&#x27;], &#x27;link&#x27; =&gt; [&#x27;a.topic-title-wrap:lt(5)&#x27;, &#x27;href&#x27;]]; 6. 读取数据 利用PDO读取数据 12345678910111213141516&lt;?phprequire &#x27;../vendor/autoload.php&#x27;;$db = new \\App\\Handle\\PdoHandle();//查询$sql = &quot;select * from `posts` limit 0,10&quot;;$pdoStatement = $db-&gt;source-&gt;query($sql);$data = $pdoStatement-&gt;fetchAll(PDO::FETCH_ASSOC);foreach ($data as &amp;$item)&#123; //给内容解密 $item[&#x27;content&#x27;] = base64_decode($item[&#x27;content&#x27;]);&#125;var_dump($data); 篇尾希望对在看的你有点收获吧，同时我也把它上传到了github，需要的伙伴可以拉下来看下。 案例 个人博客","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://naturalgao.github.io/tags/PHP/"},{"name":"数据采集","slug":"数据采集","permalink":"https://naturalgao.github.io/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"}]},{"title":"成长，就是不断向自己妥协的过程","slug":"成长，就是不断向自己妥协的过程","date":"2019-12-13T15:54:39.000Z","updated":"2022-03-05T16:13:42.768Z","comments":true,"path":"2019/12/13/成长，就是不断向自己妥协的过程/","link":"","permalink":"https://naturalgao.github.io/2019/12/13/%E6%88%90%E9%95%BF%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%8D%E6%96%AD%E5%90%91%E8%87%AA%E5%B7%B1%E5%A6%A5%E5%8D%8F%E7%9A%84%E8%BF%87%E7%A8%8B/","excerpt":"","text":"引言​ 在新东家实习已经快一个月了，环境还可以，工作也相对轻松。 ​ 公司主要业务是电商SAS平台，开发部门算上我有5个人，3个后端两个前端，我负责后端，算一个比较正规的小团队吧。 ​ 实习期间呢，我全力负责SAS平台的三个模块后台的业务开发，分别是素材库、社区（帖子）、商学院（课程）。 ​ 这些需求对久经沙场的我来说，自然不在话下，没到一个月就完成了初步的开发，接下来只需要与前端对接完就可以了。 事情经过但是这几天与leader发生了一些摩擦和争执，百般无奈下，我也只好向他妥协。 主要两个件事： 字段必填 ​ 起初的时候我给课程设计了两个字段，一个是课程的开课和结束时间。（后面我仔细看了下需求，并不需要这两个字段）我数据库给这两个字段约束了”必填“ 就是 不能为null。 ​ 他可能迁移数据的时候，报了这两个字段没有默认值导致错误了吧~ 于是截图给了我，什么也不说。然后我就解释说，这两个字段设置必填才合理，不应该设置默认值。 ​ 然后他给我的回应是：必填也要有默认值 （我一头雾水…） 代码冗余 ​ 继 ”字段“ 事件后，他也对我写的一个接口进行了审查。 我写的一个 推荐产品的Api接口，可以根据不同的分类，筛选出可选的产品。 ​ 举个例子： ​ 产品类型有：商品 和课程 ​ 我需要根据这个类型 去对应的表拿可选的数据。后台添加数据的时候也有这个需求，于是我就写在了一个Api，前端和后台都可以共用这个接口。 ​ 于是，他就觉得这样不行，要求我拆分开来。 我问他原因呢，他又说不出来，我以为他不了解需求，就不断的向他讲述，最后没有用，结果自然闹得很僵。 ​ 我们就这样僵了两三天吧，他就找我谈话了，说要我适应环境，把业务都写在一个Function 里，因为昨天同事看了我的代码，跳来跳去的，看不懂~ ， ​ 我说我可以对我这块业务写个详细的文档，这也不行，无奈下，我也只好妥协。刚来不久，很多东西都不能硬性的去改变，也只能去适应他们的开发方式。 ​ 接着，他对我的接口设计又有意见了。社区下的帖子和商学院里的课程都能评论，回复，点赞。 于是我把这些各自写成一个接口，只需要传参数识别是课程还是帖子就行了。他要求我把这些拆分出来，就是说课程的评论和帖子的评论不能一个接口。百般的解析下,无用，我也只好再一次妥协。 修改后的对比 修改后的代码我真的不想看~ 感觉要被后面的人挖祖坟~~ 就简单帖一个创建评论操作的对比吧~ 修改前： 创建评论操作入口 12345678910111213141516171819202122232425262728/** * 创建评论 * @param CommentRequest $request * @param $id * @return mixed */public function createComment(CommentRequest $request, $id)&#123; //获取type，根据typpe 获取对应的query $type = $request-&gt;input(&#x27;type&#x27;); $query = BaseModel::getQuery($type); $data = $request-&gt;except(&#x27;type&#x27;); //检查对象是否存在 try &#123; $object = $query-&gt;findOrFail($id); &#125; catch (ModelNotFoundException $exception) &#123; return $this-&gt;failed(&#x27;对象不存在&#x27;); &#125; try &#123; //把对象和数据传到创建评论操作 createCommentHandle NewRetailCommonComment::createCommentHandle($object, $data); return $this-&gt;success(&#x27;评论成功&#x27;); &#125; catch (\\Exception $exception) &#123; return $this-&gt;failed($exception-&gt;getMessage()); &#125;&#125; CommentRequest.php Request 中传个类型和内容 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\\Http\\Requests\\Api;use Illuminate\\Foundation\\Http\\FormRequest;class CommentRequest extends FormRequest&#123; /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() &#123; return true; &#125; /** * Get the validation rules that apply to the request. * * @return array */ public function rules() &#123; return [ &#x27;type&#x27; =&gt; &#x27;required|in:post,course&#x27;, &#x27;content&#x27; =&gt; &#x27;required|min:1&#x27; ]; &#125;&#125; BaseModel.php 根据类型获取不同的实例 123456789101112131415161718192021222324/** * 获取不同的$Query * @param $type * @return bool|\\Illuminate\\Database\\Eloquent\\Builder */public static function getQuery($type)&#123; switch ($type): case &#x27;post&#x27;: return NewRetailCommunityPost::query(); break; case &#x27;course&#x27;: return NewRetailCourse::query(); break; case &#x27;comment&#x27;: return NewRetailCommonComment::query(); break; case &#x27;replies&#x27;: return NewRetailCommonCommentReplies::query(); break; default: return false; endswitch;&#125; NewRetailCommonComment.php 12345678910111213141516171819202122232425262728293031323334353637/** * 添加评论处理操作 * @param $object * @param $data * @return bool * @throws \\Exception */public static function createCommentHandle($object, $data): bool&#123; //判断对象的类型 获取实例 if ($object instanceof NewretailCommunityPost) &#123; $model = new NewretailCommunityPost(); &#125; elseif ($object instanceof NewRetailCourse) &#123; $model = new NewRetailCourse(); &#125; //判断对象是否有效 $model::isEffective($object); //评论功能是否开启 if (!$model::isComment()) &#123; throw new \\Exception(&#x27;评论功能还没有开启哦~~&#x27;); &#125; //是否需要审核 if (!$model::commentIsReview()) &#123; $data[&#x27;status&#x27;] = CommunityPostEnum::ONE; &#125; //返回创建所需的共用数据 $uuidAndCustomer = BaseModel::getCustomerAndUuid(); //数组合并 $data = array_merge($data, $uuidAndCustomer); //创建评论 $object-&gt;comment()-&gt;save(new NewRetailCommonComment($data)); return true;&#125; 修改后： 修改后的话，就是全部放一个Function里。实在没眼看~~ 入口（创建文章评论） 12345678910111213141516/** * 创建评论 * @param CommentRequest $request * @param NewRetailCommunityPost $post * @return mixed */public function createComment(CommentRequest $request, NewRetailCommunityPost $post)&#123; $data = $request-&gt;all(); try &#123; NewRetailCommonComment::createPostComment($data, $post); return $this&gt;success(ErrorCodeEnum::RETURN_ERROR_CODE_MSG[ErrorCodeEnum::ACTION_SUCCESS]); &#125; catch (\\Exception $exception) &#123; return $this-&gt;failed($exception-&gt;getMessage()); &#125;&#125; NewRetailCommonComment.php 123456789101112131415161718192021222324252627282930313233343536373839/** * 创建文章评论 * @param $data * @param $post * @return bool * @throws \\Exception */public static function createPostComment($data, $post): bool&#123; $model = new NewretailCommunityPost(); if ($post-&gt;is_del || $post-&gt;status != CommunityPostEnum::ONE || Auth::user()-&gt;customer_code != $post-&gt;customer_code) &#123; throw new \\Exception(ErrorCodeEnum::RETURN_ERROR_CODE_MSG[ErrorCodeEnum::POST_NO_FOUND]); &#125; /** * 判断是否可以评论 */ if (!$model::isComment()) &#123; throw new \\Exception(ErrorCodeEnum::RETURN_ERROR_CODE_MSG[ErrorCodeEnum::NO_OPEN_COMMENT_PERMISSION]); &#125; /** * 判断是否需要审核 */ if (!$model::commentIsReview()) &#123; $data[&#x27;status&#x27;] = CommunityPostEnum::ONE; &#125; $user = Auth::user(); $data = array_merge($data, [ &#x27;customer_code&#x27; =&gt; $user-&gt;customer_code, &#x27;uuid&#x27; =&gt; $user-&gt;uuid ]); $post-&gt;comment()-&gt;save(new NewRetailCommonComment($data)); return true;&#125; 创建课程评论 又需要 重新差不多的代码~~~ 总结​ 我发这篇文章的本意并不是如何的抬高自己，贬低别人，我也不认为自己写得有多好，写一些业务代码，没什么值得骄傲的。通过这件事，我领悟到了，有时候有些事情，就算你很不喜欢，很不乐意，为了生活，也得适当的妥协。成长，就是不断向自己妥协的过程。 这种环境并不是我向往的，但是生活所迫，暂时任性不了，我还是会保持我的个性。","categories":[],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://naturalgao.github.io/tags/Laravel/"},{"name":"PHP","slug":"PHP","permalink":"https://naturalgao.github.io/tags/PHP/"},{"name":"生活","slug":"生活","permalink":"https://naturalgao.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"推荐一个Laravel-admin 表单字段关联的包","slug":"推荐一个Laravel-admin-表单字段关联的包","date":"2019-12-08T06:09:38.000Z","updated":"2022-03-05T16:13:42.875Z","comments":true,"path":"2019/12/08/推荐一个Laravel-admin-表单字段关联的包/","link":"","permalink":"https://naturalgao.github.io/2019/12/08/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AALaravel-admin-%E8%A1%A8%E5%8D%95%E5%AD%97%E6%AE%B5%E5%85%B3%E8%81%94%E7%9A%84%E5%8C%85/","excerpt":"","text":"​ 相信有用Laravel 开发web应用的伙伴都有用过Larave-admin。 ​ 笔者最近遇到了个需求，需要根据表单的某个组件控制其它组件显示或者隐藏。 ​ 例如： ​ 有一个类型radio的组件，选项有官方，和教师。 ​ 还有一个是教师的select组件。 ​ 我们需要根据类型radio组件的状态来控制教师的select组件。 ​ 那如何实现呢？我翻遍了官方文档，发现并没有提供这一功能。于是我想着要不自己写一个扩展，在写之前我在网上找了各种包，发现了个非常好用的包，嘻嘻~~~ ​ 最终效果： ​ ​ 向提供者致敬，传送门 ​ 传送门有详细的使用介绍，这里我就不做教程了，希望对在看的你有帮助。","categories":[],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://naturalgao.github.io/tags/Laravel/"},{"name":"Laravel-Admin","slug":"Laravel-Admin","permalink":"https://naturalgao.github.io/tags/Laravel-Admin/"}]},{"title":"代码风格配置","slug":"代码风格配置","date":"2019-07-24T15:13:20.000Z","updated":"2022-03-05T16:13:42.797Z","comments":true,"path":"2019/07/24/代码风格配置/","link":"","permalink":"https://naturalgao.github.io/2019/07/24/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E9%85%8D%E7%BD%AE/","excerpt":"","text":"引言在多人开发协作中，每个人的开发风格都不一样，遵循标准的代码规范有利于多人协作，日后的维护成本也低。 PHP_CodeSniffer基础这是一个代码风格检测工具，包含两个脚本：phpcs和phpcbf phpcs 检测代码风格 phpcbf 修正代码风格 安装1composer global require &quot;squizlabs/php_codesniffer=*&quot; 安装完成后会在全局依赖包目录生成phpcbf 和 phpcs 文件 window下 是.bat 查看composer全局依赖包路径 1composer global config bin-dir --absolute PhpStorm配置位置：file-&gt;setting-&gt;Tools-&gt;External Tools 添加 phpcs 添加phpcbf 参数说明Program：全局composer依赖包phpcs&#x2F;phpcbf路径 例如我的安装路径为： 123/Users/mac/.composer/vendor/bin/phpcsProgram：/Users/mac/.composer/vendor/bin/phpcs Arguments:：是$FileDir$/$FileName$ Working directory：是$ProjectFileDir$ 使用方法 git提交时对代码进行检查Php-ccPHP code check 利用git hook、phplint、phpcs，在code commit的时候对php代码进行语法检测、代码风格检查，如果有问题，不允许提交。github 安装1composer require zhenggui/php-cc 安装成功后执行 1composer exec phpcc install 该命令会检查phplint、phpcs的安装情况，并将git原有的pre-commit钩子备份，再将php-cc的pre-commit钩子拷贝至.git/hooks中。 这样，在git commit之前，就会执行phplint和phpcs检查待提交的文件，如果不满足要求，则会阻止代码提交。 开启phplint1composer exec -v phpcc config phplint/phpcs true/false true开启, false 关闭 卸载1composer exec -v phpcc remote","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"https://naturalgao.github.io/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"PHP正则表达式","slug":"PHP正则表达式","date":"2019-07-24T05:46:19.000Z","updated":"2022-03-05T16:13:43.111Z","comments":true,"path":"2019/07/24/PHP正则表达式/","link":"","permalink":"https://naturalgao.github.io/2019/07/24/PHP%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"PHP正则表达式基础 作用 分割、查找、匹配、替换字符串 分隔符 正斜线（&#x2F;）、hash符号（#）以及取反符号（~） 通用原子 \\d (0-9) \\D （除了0-9） \\w （数字，字母，下划线） \\W （除了数字，字母，下划线） \\s （空白符） \\S （除了空白符） 元字符 .（除了换行符外的任意字符） *（匹配前面的单元出现0-n次） ? （匹配前面的单元出现0-1次） ^（必须以某个单元开头） $ （必须以某个单元结尾） +（出现一次或者多次） {n} （出现n次） {n,} （大于等于n次） {n,m} （大于等于n并且小于等于m次） [] （集合，[abc]匹配a或者b或者c） [^] （取反） | （或者） [-] （范围） 模式修正符 i m e s U x A D u 后向引用123$str = &#x27;&lt;b&gt;abc&lt;/b&gt;&#x27;;$pattern = &#x27;/&lt;b&gt;(.*)&lt;\\/b&gt;/&#x27;;preg_replace($pattern, &#x27;\\\\1&#x27;,$str); 贪婪模式123$str = &#x27;&lt;b&gt;abc&lt;/b&gt;&lt;b&gt;bcd&lt;/b&gt;&#x27;;$pattern = &#x27;/&lt;b&gt;.* &lt;\\/b&gt;/&#x27;;$preg_replace_all($pattern,&#x27;\\\\1&#x27;,$str);","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://naturalgao.github.io/tags/PHP/"}]},{"title":"数据库维护命令","slug":"数据库维护命令","date":"2019-07-19T07:35:36.000Z","updated":"2022-03-05T16:13:42.851Z","comments":true,"path":"2019/07/19/数据库维护命令/","link":"","permalink":"https://naturalgao.github.io/2019/07/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4%E5%91%BD%E4%BB%A4/","excerpt":"","text":"前言数据库维护频率较低，也有很多可视化管理工具，但作为程序员，还是有必要了解下维护数据库表命令的 或者 1RENAME TABLE post to posts; 修改字符集1ALTER TABLE posts charset gbk; 清空表数据1DELETE FROM posts; 这种方式是一条一条的删除，有点慢.可以使用以下方式 1TRUNCATE posts; 删除表1DROP TABLE posts; 加条件，判断表是否存在,避免报错。 1DROP TABLE if EXISTS posts; 字段修改类型 修改title字段为字符串并且不能为空 1ALTER TABLE posts MODIFY title vachar(50) not null; 修改字段名和类型 将字段title修改为name，并且修改类型为char(30) 不能为null 1ALTER TABLE posts CHANGE title name char(30) not null; 添加字段 添加一个 content 字段，类型为 text 1ALTER TABLE posts ADD content text; 插入到某个字段后面 插入到title的后面 1ALTER TABLE posts ADD content text AFTER title; 插入到最前面 1ALTER TABLE posts ADD content text first; 删除字段 删除 content 字段 1ALTER TABLE posts drop content; 主键移除自增列 移除id自增 1ALTER TABLE posts MODIFY id int not null; 移除主键 要先移除自增列，才可以移除主键成功 1ALTER TABLE posts drop PRIMARY key; 添加主键 添加id主键 1ALTER TABLE posts ADD PRIMARY key (id); 添加自增列 添加id 自增 1ALTER TABLE posts MODIFY id int not null AUTO_INCREMENT; 添加主键和自增列1ALTER TABLE posts MODIFY id int not null AUTO_INCREMENT,ADD PRIMARY key (id);","categories":[],"tags":[{"name":"Database","slug":"Database","permalink":"https://naturalgao.github.io/tags/Database/"}]},{"title":"Laravel 事件监听","slug":"Laravel中的事件监听","date":"2019-07-15T07:33:25.000Z","updated":"2022-03-05T16:13:42.994Z","comments":true,"path":"2019/07/15/Laravel中的事件监听/","link":"","permalink":"https://naturalgao.github.io/2019/07/15/Laravel%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/","excerpt":"Laravel 框架中的事件监听","text":"Laravel 框架中的事件监听 1.什么是“事件监听“？从字面上就可以看出来，无非就是监听一个事件。 2.使用场景例句一个物流发货的场景：我有个小程序商城，用户下单后需要在后台发货，发完货后我想在微信发送个模块通知提示用户，我想了想用户不登录微信或者把消息提示关闭了，那岂不是不能实时通知用户已经发货了，我决定再加个短信通知用户。有了模块通知，短信通知后我还嫌不够…然后我继续加…. 通常我们会这么写： 1234567891011121314&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class OrderController extends Controller&#123; public function sendGoods() &#123; //@todo:发货逻辑 //@todo:模块通知逻辑 //@todo:短信通知逻辑 //@todo:等等.... &#125;&#125; **这样写不是不可以，但是逻辑功能越来越多，控制器只会变得臃肿起来，后期不便于维护。这时候可能会有人说，那我可以封装起来啊，是的，你可以封装起来，然后就可以用简短的代码来实现。但是实际项目中，会涉及多人开发，这样就不方便了。所以推荐使用laravel自带的“事件监听“… ** 3.使用”事件监听”优化代码3.1 打开终端-&gt;切换到项目根目录-&gt;使用artisan命令创建事件监听文件 1php artisan make:event OrderEvent 执行完命令，发现 app&#x2F;Events 目录下多了个 OrderEvent.php 文件 我们可以打开看看… 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\\Events;use Illuminate\\Broadcasting\\Channel;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Broadcasting\\PrivateChannel;use Illuminate\\Broadcasting\\PresenceChannel;use Illuminate\\Foundation\\Events\\Dispatchable;use Illuminate\\Broadcasting\\InteractsWithSockets;use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;class OrderEvent&#123; use Dispatchable, InteractsWithSockets, SerializesModels; /** * Create a new event instance. * * @return void */ public function __construct() &#123; // &#125; /** * Get the channels the event should broadcast on. * * @return \\Illuminate\\Broadcasting\\Channel|array */ public function broadcastOn() &#123; return new PrivateChannel(&#x27;channel-name&#x27;); &#125;&#125; 简单的修改下构造函数，因为到时候我们可能会 传入 购买商品的 用户 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\Events;use App\\User;use Illuminate\\Broadcasting\\Channel;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Broadcasting\\PrivateChannel;use Illuminate\\Broadcasting\\PresenceChannel;use Illuminate\\Foundation\\Events\\Dispatchable;use Illuminate\\Broadcasting\\InteractsWithSockets;use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;class OrderEvent&#123; use Dispatchable, InteractsWithSockets, SerializesModels; public $user; /** * Create a new event instance. * * @return void */ public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; /** * Get the channels the event should broadcast on. * * @return \\Illuminate\\Broadcasting\\Channel|array */ public function broadcastOn() &#123; return new PrivateChannel(&#x27;channel-name&#x27;); &#125;&#125; 3.2 绑定事件 打开 app&#x2F;Providers&#x2F;EventServiceProvider.php 文件，找到 成员属性 listen下： 12345protected $listen = [ Registered::class =&gt; [ SendEmailVerificationNotification::class, ],]; 把事件关联起来，修改为： 123456789protected $listen = [ Registered::class =&gt; [ SendEmailVerificationNotification::class, ], &#x27;App\\Events\\OrderEvent&#x27; =&gt; [ &#x27;App\\Listeners\\sendModel&#x27;, &#x27;App\\Listeners\\sendPhone&#x27;, ]]; 接着打开终端，执行 artisan 命令 生成 监听文件 1php artisan event:generate 然后我们可以在 app&#x2F;Listeners 文件下发现多了两个文件 打开这两个文件，依次修改为： sendModel.php: 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\\Listeners;use App\\Events\\OrderEvent;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;class sendModel&#123; /** * Create the event listener. * * @return void */ public function __construct() &#123; // &#125; /** * Handle the event. * * @param OrderEvent $event * @return void */ public function handle(OrderEvent $event) &#123; $user = $event-&gt;user; // @todo: 当前用户 //@todo：发送消息模板逻辑 dump(&#x27;发送消息模板成功&#x27;); &#125;&#125; sendPhone.php: 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\\Listeners;use App\\Events\\OrderEvent;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;class sendPhone&#123; /** * Create the event listener. * * @return void */ public function __construct() &#123; // &#125; /** * Handle the event. * * @param OrderEvent $event * @return void */ public function handle(OrderEvent $event) &#123; $user = $event-&gt;user; // @todo: 当前用户 //@todo：发送短信消息 dump(&#x27;发送短信消息成功&#x27;); &#125;&#125; 3.3 最后我们再打开 OrderController.php 修改为: 12345678910111213141516&lt;?phpnamespace App\\Http\\Controllers;use App\\Events\\OrderEvent;use App\\User;use Illuminate\\Http\\Request;class OrderController extends Controller&#123; public function sendGoods() &#123; $user = User::find(1); //@todo:发货逻辑 dump(&#x27;发货成功!!&#x27;); event(new OrderEvent($user)); &#125;&#125; 3.4 绑定路由 1Route::get(&#x27;/sendGoods&#x27;,&#x27;OrderController@sendGoods&#x27;); 3.5 访问路由结果： 4. 总结这样是不是简单，便于维护了许多呢… 还不会的小伙伴赶紧去试试吧！如果对你有帮助，请给个赞，谢谢！","categories":[],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://naturalgao.github.io/tags/Laravel/"},{"name":"PHP","slug":"PHP","permalink":"https://naturalgao.github.io/tags/PHP/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2019-07-15T05:08:58.000Z","updated":"2022-03-05T16:13:42.964Z","comments":true,"path":"2019/07/15/Git常用命令/","link":"","permalink":"https://naturalgao.github.io/2019/07/15/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"git 版本控制 常用的命令","text":"git 版本控制 常用的命令 版本号1git --version 配置 配置文件 为 ~&#x2F;.gitconfig（全局） .git&#x2F;config （局部） 12345678git config --global user.email &quot;xxxx@qq.com&quot;git config --global user.name &quot;xxxx&quot;# 生成秘钥ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;# 测试ssh -T git@github.com 设置默认使用文本编辑器 1git config --global core.editor sub1 alias 取别名，缩减代码 1git config --global alias.c commit 基础 创建 1git init 拉取 1git clone https://github.com/NaturalGao/naturalgao.github.io.git 添加文件 12git add . //添加全部文件git add a.php //添加a.php文件 修改文件名 1git mv a.php b.php //修改a.php文件名为b.php 删除文件 123git rm a.txt //版本库和本地文件都会删除git rm --cached a.txt //只删除版本库，保留本地 推送 12git commit -m &quot;描述&quot; 查看状态 12git status 忽略文件 文件： .gitignore 123*.txt //忽略所有txt文件/vendor //忽略vendor文件夹 日志 简单描述 12git log 查看变动信息 12git log -p 最近一次提交 12git log -p -1 查看简短信息 12git log --oneline 查看变动的文件 12git log --name-only 查看类型变化 12git log --name-status 修改最新一次提交12git commit --amend 分支 查看分支 12git branch 创建分支 12git branch dev //创建 dev分支 切换分支 12git checkout dev //切换到 dev分支 创建&amp;&amp;切换分支 12git checkout -b dev //创建并且切换到dev分支 合并分支 12git merge dev 删除分支 12git branch -d dev 已合并的分支 12git branch --merged 没有合并的分支 12git branch --no-merged 删除没有合并的分支 12git branch -D dev 暂存区 添加 12git stash 查看列表 12git stash list 恢复 123git stash apply //恢复全部git stash apply stash@&#123;1&#125; //恢复第一个 删除 12git stash pop 移除文件 12git reset HEAD a.php //移除a.php文件 恢复文件内容 12git checkout -- a.php 标签 添加 12git tab &#x27;标签&#x27; 生成压缩包12git archive master --prefix = &quot;naturalGao/&quot; --forma=zip &gt; natural.zip 移动master分支到最新12git rebase master 查看远程分支12git branch -a 拉取某个远程分支12git pull origin dev:dev 删除远程分支12git push origin --delete dev","categories":[{"name":"Git","slug":"Git","permalink":"https://naturalgao.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://naturalgao.github.io/tags/Git/"}]}],"categories":[{"name":"Git","slug":"Git","permalink":"https://naturalgao.github.io/categories/Git/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://naturalgao.github.io/tags/Linux/"},{"name":"PHP","slug":"PHP","permalink":"https://naturalgao.github.io/tags/PHP/"},{"name":"数据采集","slug":"数据采集","permalink":"https://naturalgao.github.io/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"},{"name":"Laravel","slug":"Laravel","permalink":"https://naturalgao.github.io/tags/Laravel/"},{"name":"生活","slug":"生活","permalink":"https://naturalgao.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Laravel-Admin","slug":"Laravel-Admin","permalink":"https://naturalgao.github.io/tags/Laravel-Admin/"},{"name":"其它","slug":"其它","permalink":"https://naturalgao.github.io/tags/%E5%85%B6%E5%AE%83/"},{"name":"Database","slug":"Database","permalink":"https://naturalgao.github.io/tags/Database/"},{"name":"Git","slug":"Git","permalink":"https://naturalgao.github.io/tags/Git/"}]}